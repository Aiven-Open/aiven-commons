package io.aiven.commons.strings;
/*
         Copyright 2025 Aiven Oy and project contributors

        Licensed under the Apache License, Version 2.0 (the "License");
        you may not use this file except in compliance with the License.
        You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

        Unless required by applicable law or agreed to in writing,
        software distributed under the License is distributed on an
        "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
        KIND, either express or implied.  See the License for the
        specific language governing permissions and limitations
        under the License.

        SPDX-License-Identifier: Apache-2
 */
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Stream;

import static org.assertj.core.api.Assertions.assertThat;

public class CasedStringTest {

	@MethodSource("testSegmentationData")
	@ParameterizedTest
	void testSegmentation(String pattern, CasedString.StringCase stringCase, String[] expected) {
		CasedString casedString = new CasedString(stringCase, pattern);
		assertThat(casedString.getSegments()).isEqualTo(expected);
	}

	static Stream<Arguments> testSegmentationData() {
		List<Arguments> lst = new ArrayList<>();
		lst.add(Arguments.of("CamelCase", CasedString.StringCase.CAMEL, new String[]{"Camel", "Case"}));
		lst.add(Arguments.of("CamelPMDCase", CasedString.StringCase.CAMEL,
				new String[]{"Camel", "P", "M", "D", "Case"}));
		lst.add(Arguments.of("camelCase", CasedString.StringCase.CAMEL, new String[]{"camel", "Case"}));
		lst.add(Arguments.of("camelPMDCase", CasedString.StringCase.CAMEL,
				new String[]{"camel", "P", "M", "D", "Case"}));
		lst.add(Arguments.of("PascalCase", CasedString.StringCase.PASCAL, new String[]{"Pascal", "Case"}));
		lst.add(Arguments.of("PascalPMDCase", CasedString.StringCase.PASCAL,
				new String[]{"Pascal", "P", "M", "D", "Case"}));
		lst.add(Arguments.of("pascalCase", CasedString.StringCase.PASCAL, new String[]{"pascal", "Case"}));
		lst.add(Arguments.of("pascalPMDCase", CasedString.StringCase.PASCAL,
				new String[]{"pascal", "P", "M", "D", "Case"}));
		lst.add(Arguments.of("snake_case", CasedString.StringCase.SNAKE, new String[]{"snake", "case"}));
		lst.add(Arguments.of("snake_Case", CasedString.StringCase.SNAKE, new String[]{"snake", "Case"}));
		lst.add(Arguments.of("snake__Case", CasedString.StringCase.SNAKE, new String[]{"snake", "", "Case"}));
		lst.add(Arguments.of("kebab-case", CasedString.StringCase.KEBAB, new String[]{"kebab", "case"}));
		lst.add(Arguments.of("kebab-Case", CasedString.StringCase.KEBAB, new String[]{"kebab", "Case"}));
		lst.add(Arguments.of("kebab--case", CasedString.StringCase.KEBAB, new String[]{"kebab", "", "case"}));
		lst.add(Arguments.of("phrase case", CasedString.StringCase.PHRASE, new String[]{"phrase", "case"}));
		lst.add(Arguments.of("phrase Case", CasedString.StringCase.PHRASE, new String[]{"phrase", "Case"}));
		lst.add(Arguments.of("phrase  case", CasedString.StringCase.PHRASE, new String[]{"phrase", "", "case"}));
		lst.add(Arguments.of("dot.case", CasedString.StringCase.DOT, new String[]{"dot", "case"}));
		lst.add(Arguments.of("dot..case", CasedString.StringCase.DOT, new String[]{"dot", "", "case"}));
		lst.add(Arguments.of("dot.Case", CasedString.StringCase.DOT, new String[]{"dot", "Case"}));
		return lst.stream();
	}

	@MethodSource("testToCaseData")
	@ParameterizedTest(name = "{index} {0} {1}")
	void testToCase(CasedString casedString, CasedString.StringCase stringCase, String expected) {
		assertThat(casedString.toCase(stringCase)).isEqualTo(expected);
	}

	static Stream<Arguments> testToCaseData() {
		List<Arguments> lst = new ArrayList<>();

		CasedString underTest = new CasedString(CasedString.StringCase.CAMEL, "camelCase");
		lst.add(Arguments.of(underTest, CasedString.StringCase.CAMEL, "camelCase"));
		lst.add(Arguments.of(underTest, CasedString.StringCase.SNAKE, "camel_Case"));
		lst.add(Arguments.of(underTest, CasedString.StringCase.KEBAB, "camel-Case"));
		lst.add(Arguments.of(underTest, CasedString.StringCase.PHRASE, "camel Case"));
		lst.add(Arguments.of(underTest, CasedString.StringCase.DOT, "camel.Case"));
		lst.add(Arguments.of(underTest, CasedString.StringCase.PASCAL, "CamelCase"));

		underTest = new CasedString(CasedString.StringCase.SNAKE, "snake_case");
		lst.add(Arguments.of(underTest, CasedString.StringCase.CAMEL, "snakeCase"));
		lst.add(Arguments.of(underTest, CasedString.StringCase.SNAKE, "snake_case"));
		lst.add(Arguments.of(underTest, CasedString.StringCase.KEBAB, "snake-case"));
		lst.add(Arguments.of(underTest, CasedString.StringCase.PHRASE, "snake case"));
		lst.add(Arguments.of(underTest, CasedString.StringCase.DOT, "snake.case"));
		lst.add(Arguments.of(underTest, CasedString.StringCase.PASCAL, "SnakeCase"));

		underTest = new CasedString(CasedString.StringCase.KEBAB, "kebab-case");
		lst.add(Arguments.of(underTest, CasedString.StringCase.CAMEL, "kebabCase"));
		lst.add(Arguments.of(underTest, CasedString.StringCase.SNAKE, "kebab_case"));
		lst.add(Arguments.of(underTest, CasedString.StringCase.KEBAB, "kebab-case"));
		lst.add(Arguments.of(underTest, CasedString.StringCase.PHRASE, "kebab case"));
		lst.add(Arguments.of(underTest, CasedString.StringCase.DOT, "kebab.case"));
		lst.add(Arguments.of(underTest, CasedString.StringCase.PASCAL, "KebabCase"));

		underTest = new CasedString(CasedString.StringCase.PHRASE, "phrase case");
		lst.add(Arguments.of(underTest, CasedString.StringCase.CAMEL, "phraseCase"));
		lst.add(Arguments.of(underTest, CasedString.StringCase.SNAKE, "phrase_case"));
		lst.add(Arguments.of(underTest, CasedString.StringCase.KEBAB, "phrase-case"));
		lst.add(Arguments.of(underTest, CasedString.StringCase.PHRASE, "phrase case"));
		lst.add(Arguments.of(underTest, CasedString.StringCase.DOT, "phrase.case"));
		lst.add(Arguments.of(underTest, CasedString.StringCase.PASCAL, "PhraseCase"));

		underTest = new CasedString(CasedString.StringCase.DOT, "dot.case");
		lst.add(Arguments.of(underTest, CasedString.StringCase.CAMEL, "dotCase"));
		lst.add(Arguments.of(underTest, CasedString.StringCase.SNAKE, "dot_case"));
		lst.add(Arguments.of(underTest, CasedString.StringCase.KEBAB, "dot-case"));
		lst.add(Arguments.of(underTest, CasedString.StringCase.PHRASE, "dot case"));
		lst.add(Arguments.of(underTest, CasedString.StringCase.DOT, "dot.case"));
		lst.add(Arguments.of(underTest, CasedString.StringCase.PASCAL, "DotCase"));

		underTest = new CasedString(CasedString.StringCase.PASCAL, "PascalCase");
		lst.add(Arguments.of(underTest, CasedString.StringCase.CAMEL, "pascalCase"));
		lst.add(Arguments.of(underTest, CasedString.StringCase.SNAKE, "Pascal_Case"));
		lst.add(Arguments.of(underTest, CasedString.StringCase.KEBAB, "Pascal-Case"));
		lst.add(Arguments.of(underTest, CasedString.StringCase.PHRASE, "Pascal Case"));
		lst.add(Arguments.of(underTest, CasedString.StringCase.DOT, "Pascal.Case"));
		lst.add(Arguments.of(underTest, CasedString.StringCase.PASCAL, "PascalCase"));

		underTest = new CasedString(CasedString.StringCase.DOT, "one..two");
		lst.add(Arguments.of(underTest, CasedString.StringCase.CAMEL, "oneTwo"));
		lst.add(Arguments.of(underTest, CasedString.StringCase.SNAKE, "one__two"));
		lst.add(Arguments.of(underTest, CasedString.StringCase.KEBAB, "one--two"));
		lst.add(Arguments.of(underTest, CasedString.StringCase.PHRASE, "one  two"));
		lst.add(Arguments.of(underTest, CasedString.StringCase.DOT, "one..two"));
		lst.add(Arguments.of(underTest, CasedString.StringCase.PASCAL, "OneTwo"));

		return lst.stream();
	}

	@MethodSource("testAssembleData")
	@ParameterizedTest(name = "{index} {0} {1}")
	void testAssemble(CasedString.StringCase underTest, String[] data, String expected) {
		assertThat(underTest.assemble(data)).isEqualTo(expected);
	}

	static Stream<Arguments> testAssembleData() {
		List<Arguments> lst = new ArrayList<>();
		String[] emptyFirst = {"", "one", "two"};
		String[] emptyMiddle = {"one", "", "two"};
		String[] emptyEnd = {"one", "two", ""};
		String[] nullFirst = {null, "one", "two"};
		String[] nullMiddle = {"one", null, "two"};
		String[] nullEnd = {"one", "two", null};
		String[] doubleEmpty = {"one", "", "", "two"};
		String[] doubleNull = {"one", null, null, "two"};

		CasedString.StringCase underTest = CasedString.StringCase.CAMEL;
		lst.add(Arguments.of(underTest, emptyFirst, "oneTwo"));
		lst.add(Arguments.of(underTest, emptyMiddle, "oneTwo"));
		lst.add(Arguments.of(underTest, emptyEnd, "oneTwo"));
		lst.add(Arguments.of(underTest, nullFirst, "oneTwo"));
		lst.add(Arguments.of(underTest, nullMiddle, "oneTwo"));
		lst.add(Arguments.of(underTest, nullEnd, "oneTwo"));
		lst.add(Arguments.of(underTest, doubleEmpty, "oneTwo"));
		lst.add(Arguments.of(underTest, doubleNull, "oneTwo"));

		underTest = CasedString.StringCase.PASCAL;
		lst.add(Arguments.of(underTest, emptyFirst, "OneTwo"));
		lst.add(Arguments.of(underTest, emptyMiddle, "OneTwo"));
		lst.add(Arguments.of(underTest, emptyEnd, "OneTwo"));
		lst.add(Arguments.of(underTest, nullFirst, "OneTwo"));
		lst.add(Arguments.of(underTest, nullMiddle, "OneTwo"));
		lst.add(Arguments.of(underTest, nullEnd, "OneTwo"));
		lst.add(Arguments.of(underTest, doubleEmpty, "OneTwo"));
		lst.add(Arguments.of(underTest, doubleNull, "OneTwo"));

		underTest = CasedString.StringCase.SNAKE;
		lst.add(Arguments.of(underTest, emptyFirst, "_one_two"));
		lst.add(Arguments.of(underTest, emptyMiddle, "one__two"));
		lst.add(Arguments.of(underTest, emptyEnd, "one_two_"));
		lst.add(Arguments.of(underTest, nullFirst, "one_two"));
		lst.add(Arguments.of(underTest, nullMiddle, "one_two"));
		lst.add(Arguments.of(underTest, nullEnd, "one_two"));
		lst.add(Arguments.of(underTest, doubleEmpty, "one___two"));
		lst.add(Arguments.of(underTest, doubleNull, "one_two"));

		underTest = CasedString.StringCase.KEBAB;
		lst.add(Arguments.of(underTest, emptyFirst, "-one-two"));
		lst.add(Arguments.of(underTest, emptyMiddle, "one--two"));
		lst.add(Arguments.of(underTest, emptyEnd, "one-two-"));
		lst.add(Arguments.of(underTest, nullFirst, "one-two"));
		lst.add(Arguments.of(underTest, nullMiddle, "one-two"));
		lst.add(Arguments.of(underTest, nullEnd, "one-two"));
		lst.add(Arguments.of(underTest, doubleEmpty, "one---two"));
		lst.add(Arguments.of(underTest, doubleNull, "one-two"));

		underTest = CasedString.StringCase.PHRASE;
		lst.add(Arguments.of(underTest, emptyFirst, " one two"));
		lst.add(Arguments.of(underTest, emptyMiddle, "one  two"));
		lst.add(Arguments.of(underTest, emptyEnd, "one two "));
		lst.add(Arguments.of(underTest, nullFirst, "one two"));
		lst.add(Arguments.of(underTest, nullMiddle, "one two"));
		lst.add(Arguments.of(underTest, nullEnd, "one two"));
		lst.add(Arguments.of(underTest, doubleEmpty, "one   two"));
		lst.add(Arguments.of(underTest, doubleNull, "one two"));

		underTest = CasedString.StringCase.DOT;
		lst.add(Arguments.of(underTest, emptyFirst, ".one.two"));
		lst.add(Arguments.of(underTest, emptyMiddle, "one..two"));
		lst.add(Arguments.of(underTest, emptyEnd, "one.two."));
		lst.add(Arguments.of(underTest, nullFirst, "one.two"));
		lst.add(Arguments.of(underTest, nullMiddle, "one.two"));
		lst.add(Arguments.of(underTest, nullEnd, "one.two"));
		lst.add(Arguments.of(underTest, doubleEmpty, "one...two"));
		lst.add(Arguments.of(underTest, doubleNull, "one.two"));

		underTest = CasedString.StringCase.SLASH;
		lst.add(Arguments.of(underTest, emptyFirst, "/one/two"));
		lst.add(Arguments.of(underTest, emptyMiddle, "one//two"));
		lst.add(Arguments.of(underTest, emptyEnd, "one/two/"));
		lst.add(Arguments.of(underTest, nullFirst, "one/two"));
		lst.add(Arguments.of(underTest, nullMiddle, "one/two"));
		lst.add(Arguments.of(underTest, nullEnd, "one/two"));
		lst.add(Arguments.of(underTest, doubleEmpty, "one///two"));
		lst.add(Arguments.of(underTest, doubleNull, "one/two"));

		return lst.stream();
	}
}
